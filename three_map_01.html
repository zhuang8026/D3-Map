<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <title>three.js 地圖：點點弧線效果</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #eff3f8;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans TC',
          sans-serif;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }
      /* #legend {
        position: absolute;
        left: 12px;
        bottom: 12px;
        background: #fff;
        padding: 8px 10px;
        border-radius: 10px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
        font-size: 12px;
        color: #333;
      } */
    </style>
  </head>
  <body>
    <div id="app"></div>
    <!-- <div id="legend">
      拖曳平移、滑輪縮放 · 示例資料：SF→Paris、NYC→Tokyo · 立柱示意
    </div> -->

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
      import { MapControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/MapControls.js';
      import { geoMercator } from 'https://unpkg.com/d3-geo@3?module';
      import * as topojson from 'https://unpkg.com/topojson-client@3?module';

      // ---- 基本場景 ----
      const el = document.getElementById('app');
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(el.clientWidth, el.clientHeight);
      el.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1220);

      const camera = new THREE.OrthographicCamera(
        -el.clientWidth / 2,
        el.clientWidth / 2,
        el.clientHeight / 2,
        -el.clientHeight / 2,
        -2000,
        2000
      );
      camera.position.set(0, 0, 500);

      const controls = new MapControls(camera, renderer.domElement);
      controls.enableRotate = false;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 1.0;
      controls.minZoom = 0.6;
      controls.maxZoom = 8;

      // ---- 墨卡托投影 ----
      const projection = geoMercator().translate([0, 0]).scale(330);
      const lonLatToVec3 = ([lon, lat], z = 0) => {
        const [x, y] = projection([lon, lat]);
        return new THREE.Vector3(x, -y, z);
      };

      // ---- 世界底圖（線條）----
      async function drawWorld() {
        // 取 TopoJSON，轉 GeoJSON。countries-110m 檔案小、速度快
        // const res = await fetch('https://unpkg.com/world-atlas@2/countries-110m.json');
        const res = await fetch('world-110m.json');
        const topo = await res.json();
        const geo = topojson.feature(topo, topo.objects.countries); // GeoJSON MultiPolygon/Polygon

        const group = new THREE.Group();
        const lineMat = new THREE.LineBasicMaterial({
          color: 0xaab8c4,
          linewidth: 1,
          transparent: false,
          opacity: 0.9,
        });

        for (const feature of geo.features) {
          const cs = feature.geometry.coordinates;
          if (feature.geometry.type === 'Polygon') {
            group.add(linesFromRings(cs, lineMat));
          } else if (feature.geometry.type === 'MultiPolygon') {
            for (const rings of cs) group.add(linesFromRings(rings, lineMat));
          }
        }
        scene.add(group);
      }

      function linesFromRings(rings, material) {
        const g = new THREE.BufferGeometry();
        const points = [];

        for (const ring of rings) {
          for (let i = 0; i < ring.length - 1; i++) {
            const v1 = lonLatToVec3(ring[i], 0);
            const v2 = lonLatToVec3(ring[i + 1], 0);
            points.push(v1.x, v1.y, 0, v2.x, v2.y, 0);
          }
        }
        g.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        return new THREE.LineSegments(g, material);
      }

      // ---- 點點弧線（InstancedMesh）----
      const dotGeo = new THREE.CircleGeometry(0.7, 12); // 點半徑
      function makeDottedArc(
        lonLatA,
        lonLatB,
        { color = 0xd36ad4, n = 220, lift = 45, z = 0.1 } = {}
      ) {
        const a = lonLatToVec3(lonLatA, z);
        const b = lonLatToVec3(lonLatB, z);
        const mid = a.clone().add(b).multiplyScalar(0.5);
        const dir = b.clone().sub(a).normalize();
        const normal = new THREE.Vector3(-dir.y, dir.x, 0);
        const c = mid.clone().add(normal.clone().multiplyScalar(lift));

        const curve = new THREE.QuadraticBezierCurve3(a, c, b);
        const mat = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: 1.0,
          depthTest: true,
        });
        const mesh = new THREE.InstancedMesh(dotGeo, mat, n);
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        const tmp = new THREE.Matrix4();
        for (let i = 0; i < n; i++) {
          const t = i / (n - 1);
          const p = curve.getPoint(t);
          tmp.makeTranslation(p.x, p.y, p.z);
          mesh.setMatrixAt(i, tmp);
        }
        mesh.userData._animate = { speed: 1.4, head: 0 };
        return mesh;
      }

      function animateDottedFlow(mesh, dt) {
        // 簡單的「亮段」循環：讓前 18% 的點更亮
        const state = mesh.userData._animate;
        state.head = (state.head + dt * state.speed) % 1;

        // 全域 alpha 版本（簡化）：亮段用兩個材質不易，所以這裡直接抖動 scale 來達成視覺跳動
        const count = mesh.count;
        const windowSize = 0.18;
        const m = new THREE.Matrix4();
        const s = new THREE.Matrix4();
        const t = new THREE.Matrix4();

        for (let i = 0; i < count; i++) {
          const phase = i / (count - 1);
          const dist = Math.min(
            Math.abs(phase - state.head),
            1 - Math.abs(phase - state.head)
          );
          const scale = dist < windowSize ? 1.6 : 0.9;

          mesh.getMatrixAt(i, m);
          // 把 m 的平移抽出再縮放
          const pos = new THREE.Vector3().setFromMatrixPosition(m);
          s.makeScale(scale, scale, 1);
          t.makeTranslation(pos.x, pos.y, pos.z);
          m.identity().multiplyMatrices(t, s);
          mesh.setMatrixAt(i, m);
        }
        mesh.instanceMatrix.needsUpdate = true;
      }

      // ---- 垂直立柱（點點往上）----
      //   function makeDottedColumn(
      //     lonLat,
      //     { color = 0xe6a200, height = 80, step = 3, zBase = 0.05 } = {}
      //   ) {
      //     const base = lonLatToVec3(lonLat, zBase);
      //     const count = Math.floor(height / step);
      //     const mat = new THREE.MeshBasicMaterial({
      //       color,
      //       transparent: true,
      //       opacity: 0.95,
      //     });
      //     const mesh = new THREE.InstancedMesh(dotGeo, mat, count);
      //     const m = new THREE.Matrix4();
      //     for (let i = 0; i < count; i++) {
      //       m.makeTranslation(base.x, base.y, zBase + i * step);
      //       mesh.setMatrixAt(i, m);
      //     }
      //     return mesh;
      //   }

      // ---- 初始化 & 資料 ----
      await drawWorld();

      // 弧線：SF→Paris、NYC→Tokyo
      const arc1 = makeDottedArc([-122.3, 37.8], [2.35, 48.86], {
        color: 0xe6a200,
        n: 230,
        lift: 50,
      });
      const arc2 = makeDottedArc([-74.0, 40.7], [139.69, 35.68], {
        color: 0xd36ad4,
        n: 250,
        lift: 70,
      });
      scene.add(arc1, arc2);

      // 立柱示意：印度、以色列、祕魯
      //   scene.add(
      //     makeDottedColumn([77.2, 28.6], { color: 0xe6a200, height: 70 }),
      //     makeDottedColumn([34.8, 31.9], { color: 0xd36ad4, height: 55 }),
      //     makeDottedColumn([-77.0, -12.0], { color: 0xf08c6a, height: 90 })
      //   );

      // ---- 迴圈 ----
      let last = performance.now();
      function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        animateDottedFlow(arc1, dt);
        animateDottedFlow(arc2, dt);
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---- resize ----
      window.addEventListener('resize', () => {
        renderer.setSize(el.clientWidth, el.clientHeight);
        camera.left = -el.clientWidth / 2;
        camera.right = el.clientWidth / 2;
        camera.top = el.clientHeight / 2;
        camera.bottom = -el.clientHeight / 2;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
